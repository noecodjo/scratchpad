#!/usr/bin/env python2
"""
= Hash length extension attacks

== Challenge

=== Challenge facts

Must have 0

    result = int(md5(self.nonce + self.user_nonces[-1]).hexdigest(),16)&((2<<(self.odds-1))-1)

* Faut que le hash & odds == 0
* odds donne `2**input - 1`
* nonce is 16 bytes
* user_nonce max length 1024

* large odds leak information about the resulting hash
* but missing 2 bytes

=== Getting there

If we keep hash material smaller than 1 block:

    block_1 = nonce + usernonce + padding
    hash_final = md5_compress(initial_state, block_1)

and we get 112 bits out of final_hash from the server. We are missing 16 bits
from being able to predict the state out of the first block.

If we play with usernonce, in block 1 we don't get any leakage of information.
The whole hash would change and we would gain nothing.

If we extend the hash (via usernonce) we can try to bruteforce the two bytes
(missing 16 bits) and compare final hash. If we get a match from server we
know we bruteforced the bytes properly.

    user input = 'a' + fake padding + 'b' + real padding
                                      ^ will go in block 2

    block_1 = nonce + 'a' + fake padding
    state = md5_compress(initial_state, block_1)

    block_2 = 'b' + real padding
    hash_final = md5_compress(state, block_2)

To solve the real challenge since we can't reuse a nonce we will have to swap
b by a counter of some sort.

Once we have the md5 state we can predict output of subsequent blocks (because
we control what's going in) and with this we can win the game by playing on the
client side and sending a usernonce that will make us win.

== References

* https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks

Copyright (C) 2016 Olivier Bilodeau

Licensed under the simplified BSD license
"""
from binascii import unhexlify
from pwn import *
import re
import sys

# from https://www.cis.upenn.edu/~cis331/project1/pymd5.py
from pymd5 import _decode, _encode, md5, md5_compress, padding

def set_odds(value):
    r.sendline('1')
    r.recvuntil(": ")
    r.sendline(str(value))

    # grab menu
    r.recvrepeat(0.2)

def set_bet(value):
    r.sendline('2')
    r.recvuntil(": ")
    print("Betting {}".format(str(value)))
    r.sendline(str(value))

    # grab menu
    r.recvrepeat(0.2)

def set_bet_all():
    r.sendline('2')
    bet_max = re.findall(r'between 0 and (\d+)\)', r.recvuntil(': '))[0]
    print("Betting {}".format(bet_max))
    r.sendline(bet_max)

    # grab menu
    r.recvrepeat(0.2)

def play(user_nonce, return_leak=False):
    """Play the game. If you want the server leak info set return_leak=True"""
    r.sendline('3')
    r.recvline()

    r.send(user_nonce)
    r.recvline() # throw away this line

    if return_leak:
        result = int(re.findall(r'generated (\d+), not', r.recvline())[0])
        result = "{:028x}".format(result)
        r.recvrepeat(0.2)
        return result

    return r.recvrepeat(0.2)

def bruteforce_block1_state(block1):
    """
    * Perform a one block md5 where we control partially what's in block1.
    * Grab 112 bits of state out of this one-block md5 from the server.
    * Perform a two-block md5 where block1 is the same as our one-block md5,
      hash-length extend it (w/ home-made padding) and reach a second block.
    * Grab 112 bits of state out of this two-block md5 from the server.

    * Locally, use md5's internal functions (md5_compress) directly to brute
      force the missing bits of the leaked state of the 1-block md5. Use the 
      bits from the two-block md5 leak to know when you guessed state1
      correctly.
    Returns the state that can be used to predict future two-block md5 hashes
    """

    # set odds to 112 to get the largest server leak
    set_odds(112)

    # small bet, lets gather intel first
    set_bet(1)

    # gather information on state1
    state1_leak = play(block1, return_leak=True)
    print("State 1 server leak: {}".format(state1_leak))

    # generate a two block md5
    block2 = str(1)
    fake_pad = padding((16+len(block1))*8) # server nonce is 16 bytes
    combined = block1 + fake_pad + block2

    # play with our two-block md5, grab leaked information of resulting hash
    target_hash = play(combined, return_leak=True)
    print("Target hash server leak: {}".format(target_hash))

    # to validate that we guessed state1 correctly, lets try to predict the
    # result of a 2-block hash where state1 is fixed by us. Compare that with
    # target_hash from the server and if we have a match we know that we guessed
    # state1 correctly.
    found = False
    guessed_state = ""
    pad = padding((16+len(combined))*8)
    for i in range(2**16-1):
        attempt = "{:04x}{}".format(i, state1_leak)

        guessed_state = _decode(unhexlify(attempt), 16)
        h = _encode(md5_compress(guessed_state, block2 + pad), 16).encode('hex')

        # have I guessed state1 right?
        if (target_hash in h):
            print("Hash found: {} / mid-state guessed: {}".format(h, attempt))
            found = True
            break

    if not found:
        print("Couldn't find the state. I won't be able to cheat. Goodbye")
        sys.exit(1)

    return guessed_state

def win_money(block1, guessed_state, odds=4):
    """
    With a given block1 and internal md5 state, craft md5s hashes that will
    meet the game's requirements. Play until enough money has been won.

    md5_compress(state, block1 + attack padding + forged block2 + padding)
    """
    set_bet_all()
    set_odds(odds)

    for i in range(2**16-1):

        block2 = '_{}'.format(str(i))
        fake_pad = padding((16+len(block1))*8) # server nonce is 16 bytes

        pad = padding((16+len(block1 + fake_pad + block2))*8)
        h = _encode(md5_compress(guessed_state, block2 + pad), 16).encode('hex')

        # will I win with this hash?
        if (int(h, 16) & ((2<<(odds-1))-1)) == 0:
            print("I should win with this: {} (md5 will be: {})".format(block2, h))

            reply = play(block1 + fake_pad + block2)
            if 'Holy shit you have a lot of money.' in reply:
                return reply

            set_bet_all()

        # show some progress
        if (i % 1000) == 0:
            print("working hard...")

if __name__ == "__main__":

    r = remote('localhost', 4321, timeout=0.2)
    r.recvlines(30, timeout=1)

    block1 = b'a'
    guessed_state = bruteforce_block1_state(block1)

    result = win_money(block1, guessed_state, odds=10)
    print("I got the flag!! Here's the server response:\n\n{}".format(result))
